package org.lemon.sort;

/**
 * 选择排序
 * 冒泡排序 找出最大的数，排到第一位
 * 插入排序  先让0-0位置有序，然后让0-1有序，然后让0-2有序，依次类推  时间复杂度要按最差的数据来推
 * <p>
 * <p>
 * 两位位置的替换的使用位运算来实现
 * 二分
 * 1、在arr上，找满足>=value的最左侧位置
 * 2、在arr上，找满足<=value的最右侧位置
 * 局部最小值 解题思路
 * <p>
 * 异或运算  无进位相加    0^N == N   N^N == 0  它同时满足交换率和结合率，也就是说一堆数，无论怎么调整顺序，它们异或的结果是一样的
 * 交互两个数的值（这个只要知道原理，其实是炫技，存在一定的问题）   两个对象对应的内存地址必须不一样，否则会出问题
 * <p>
 * 2、一个数组中有一种数出现了奇数次，其他数都是偶数次，怎么找到并打印这种数 ？？  异或运算
 * <p>
 * 3、怎么把一个int类型的数，提取出最右侧的1来？
 * <p>
 * 4、怎么从一个数组中找出两种出现了奇数次的数，其他都是偶数次？？？
 * <p>
 * 5、找出一个int数二进制里面1的个数
 * <p>
 * <p>
 * 自己先把上面的算法全部实现一遍，并且整理出现了，然后看后面的练习课程
 */
public class SortUtil {
}
